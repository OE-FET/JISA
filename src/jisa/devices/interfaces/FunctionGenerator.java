package jisa.devices.interfaces;

import jisa.devices.DeviceException;

import java.io.IOException;
import java.util.List;

public interface FunctionGenerator extends Instrument{
    // enum for different types
    // getter and setter

    public static String getDescription() {
        return "Function Generator";
    }

    /**
     * Check if the waveform is one that can be generated by the function generator.
     * @param waveform the waveform to the check
     * @return if the waveform passes the check
     */
    public boolean validateWaveform(Waveform waveform);

    /**
     * Turns on the function generator (i.e. enable output)
     *
     * @throws DeviceException Upon incompatibility with device
     * @throws IOException     Upon communications error
     */
    void turnOn() throws IOException, DeviceException;

    /**
     * Turns off the function generator.
     *
     * @throws DeviceException Upon incompatibility with device
     * @throws IOException     Upon communications error
     */
    void turnOff() throws IOException, DeviceException;

    /**
     * Returns whether the function generator is on or not.
     *
     * @return Is it on?
     *
     * @throws DeviceException Upon incompatibility with device
     * @throws IOException     Upon communications error
     */
    boolean isOn() throws IOException, DeviceException;

    /**
     * Set the waveform for the function generator
     * @param waveform the waveform to be set
     * @throws DeviceException Upon incompatibility with device
     * @throws IOException     Upon communications error
     */
    void setWaveform(Waveform waveform) throws DeviceException, IOException;

    /**
     * Set the waveform and turn the function generator on.
     */
    void outputWaveform(Waveform waveform) throws DeviceException, IOException;

    /**
     * Returns the list of supported classes
     * @return list of classes that is supported.
     */
    List<Class<? extends Waveform>> getSupportedWaveforms();

    /**
     * Reset the device.
     * @throws IOException Upon communications error
     */
    void reset() throws IOException;

    /**
     * Get the output impedance of the function generator.
     *
     * Note that it is important that the output impedance is matched correctly so that the actual voltage at load
     * is correct. If the load is not terminated (i.e. high impedance load), the measured voltage at the output
     * will be doubled.
     * For some function generators, it might be possible to change the output impedance, but it is probably best
     * to keep it as 50 Ohms!
     *
     * @return Output impedance in Ohms.
     * @throws IOException Upon communications error
     */
    default double getOutputImpedance() throws IOException {return 50;}

    public static interface Waveform {
        public static String getDescription() {return "Abstract Waveform";}

        /**
         * Evaluate the waveform at time t (NOT TESTED!!!)
         * @param t time (in seconds) at which the waveform is to be evaluated
         * @return the waveform value in Volts
         */
        public double evaluateWaveform(double t);

        /**
         * Same as above, but the function takes in a list of time, and evaluate at every time
         * @param t list of time (in seconds)
         * @return the waveform values in Volts
         */
        public default double[] evaluateWaveform(double[] t)
        {
            double[] result = new double[t.length];
            for(int i = 0; i < t.length; i++)
                result[i] = evaluateWaveform(t[i]);
            return result;
        }
    }

    public static class SineWave implements Waveform {

        /**
         * The descriptor for the sine wave. Everything is in SI units (V, rad, V, Hz respectively).
         * The amplitude is the mathematical amplitude, not the Vpp amplitude.
         */
        private final double amplitude, phase, offset, frequency;

        public double getAmplitude() {
            return amplitude;
        }

        public double getPhase() {
            return phase;
        }

        public double getOffset() {
            return offset;
        }

        public double getFrequency() {
            return frequency;
        }

        public SineWave(double amplitude, double frequency, double offset, double phase)
        {
            this.amplitude = Math.abs(amplitude);
            this.frequency = Math.abs(frequency);
            this.offset = offset;
            this.phase = phase;
        }

        public static  String getDescription() {return "Sine wave";}

        @Override
        public double evaluateWaveform(double t){
            return amplitude*Math.sin(frequency*t*Math.PI*2 + phase) + offset;
        }

    }

    public static class SquareWave implements Waveform {

        /**
         * The descriptor for the square wave. Everything is in SI units (V, rad, V, Hz respectively).
         * The amplitude is the mathematical amplitude, not the Vpp amplitude.
         * By default, the wave is zero centered, and the dutyCycle is 0.5 (or 50%).
         */
        private final double amplitude, phase, offset, frequency, dutyCycle;

        public double getAmplitude() {
            return amplitude;
        }

        public double getPhase() {
            return phase;
        }

        public double getOffset() {
            return offset;
        }

        public double getFrequency() {
            return frequency;
        }

        public double getDutyCycle() {
            return dutyCycle;
        }

        public SquareWave(double amplitude, double frequency, double offset){
            this.amplitude = Math.abs(amplitude);
            this.frequency = Math.abs(frequency);
            this.offset = offset;
            this.phase = 0;
            this.dutyCycle = 0.5;
        }

        public SquareWave(double amplitude, double frequency, double offset, double dutyCycle, double phase){
            this.amplitude = Math.abs(amplitude);
            this.frequency = Math.abs(frequency);
            this.phase = phase;
            this.offset = offset;
            this.dutyCycle = Math.abs(dutyCycle);
        }

        @Override
        public double evaluateWaveform(double t) {
            double curr_cycle_fraction = (frequency*t + phase/Math.PI/2) % 1;

            if (curr_cycle_fraction > dutyCycle)
                return offset + amplitude;
            else
                return offset - amplitude;
        }
    }
}
